<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>scrapli_asyncssh.transport.asyncssh_ API documentation</title>
<meta name="description" content="scrapli_asyncssh.transport.asyncssh_" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>scrapli_asyncssh.transport.asyncssh_</code></h1>
</header>
<section id="section-intro">
<p>scrapli_asyncssh.transport.asyncssh_</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;scrapli_asyncssh.transport.asyncssh_&#34;&#34;&#34;
import asyncio
from threading import Lock
from typing import Any, Dict, Optional, Tuple

from asyncssh import connect
from asyncssh.connection import SSHClientConnection
from asyncssh.misc import PermissionDenied
from asyncssh.stream import SSHReader, SSHWriter

from scrapli.decorators import requires_open_session
from scrapli.exceptions import KeyVerificationFailed, ScrapliAuthenticationFailed, ScrapliTimeout
from scrapli.ssh_config import SSHConfig, SSHKnownHosts
from scrapli.transport import AsyncTransport

ASYNCSSH_TRANSPORT_ARGS = (
    &#34;auth_username&#34;,
    &#34;auth_private_key&#34;,
    &#34;auth_password&#34;,
    &#34;auth_strict_key&#34;,
    &#34;ssh_config_file&#34;,
    &#34;ssh_known_hosts_file&#34;,
    &#34;timeout_socket&#34;,
)


class AsyncSSHTransport(AsyncTransport):
    def __init__(
        self,
        host: str,
        port: int = -1,
        auth_username: str = &#34;&#34;,
        auth_private_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_strict_key: bool = True,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        ssh_config_file: str = &#34;&#34;,
        ssh_known_hosts_file: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        AsyncSSHTransport Object

        Inherit from Transport ABC
        AsyncSSHTransport &lt;- Transport (ABC)

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_private_key: path to private key for authentication
            auth_password: password for authentication
            auth_strict_key: True/False to enforce strict key checking (default is True)
            timeout_socket: timeout for establishing socket in seconds
            timeout_transport: timeout for ssh transport in seconds
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; is not currently implemented w/ asyncssh
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            ssh_config_file: string to path for ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        cfg_port, cfg_user, cfg_private_key = self._process_ssh_config(host, ssh_config_file)

        if port == -1:
            port = cfg_port or 22

        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )

        self.auth_username: str = auth_username or cfg_user
        self.auth_private_key: str = auth_private_key or cfg_private_key
        self.auth_password: str = auth_password
        self.auth_strict_key: bool = auth_strict_key
        self.ssh_known_hosts_file: str = ssh_known_hosts_file
        self.port = port
        self.session_lock: Lock = Lock()

        self.session: SSHClientConnection
        self.stdout: SSHReader
        self.stdin: SSHWriter
        self.stderr: SSHReader

    @staticmethod
    def _process_ssh_config(host: str, ssh_config_file: str) -&gt; Tuple[Optional[int], str, str]:
        &#34;&#34;&#34;
        Method to parse ssh config file

        In the future this may move to be a &#39;helper&#39; function as it should be very similar between
        asyncssh and and paramiko/ssh2-python... for now it can be a static method as there may be
        varying supported args between the transport drivers.

        Args:
            host: host to lookup in ssh config file
            ssh_config_file: string path to ssh config file; passed down from `Scrape`, or the
                `NetworkDriver` or subclasses of it, in most cases.

        Returns:
            Tuple: port to use for ssh, username to use for ssh, identity file (private key) to
                use for ssh auth

        Raises:
            N/A

        &#34;&#34;&#34;
        ssh = SSHConfig(ssh_config_file)
        host_config = ssh.lookup(host)
        return host_config.port, host_config.user or &#34;&#34;, host_config.identity_file or &#34;&#34;

    def _verify_key(self) -&gt; None:
        &#34;&#34;&#34;
        Verify target host public key, raise exception if invalid/unknown

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            KeyVerificationFailed: if host is not in known hosts

        &#34;&#34;&#34;
        known_hosts = SSHKnownHosts(self.ssh_known_hosts_file)

        if self.host not in known_hosts.hosts.keys():
            raise KeyVerificationFailed(f&#34;{self.host} not in known_hosts!&#34;)

    def _verify_key_value(self) -&gt; None:
        &#34;&#34;&#34;
        Verify target host public key, raise exception if invalid/unknown

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            KeyVerificationFailed: if host is in known hosts but public key does not match

        &#34;&#34;&#34;
        known_hosts = SSHKnownHosts(self.ssh_known_hosts_file)

        remote_server_key = self.session.get_server_host_key()
        remote_public_key = remote_server_key.export_public_key().split()[1].decode()

        if known_hosts.hosts[self.host][&#34;public_key&#34;] != remote_public_key:
            raise KeyVerificationFailed(
                f&#34;{self.host} in known_hosts but public key does not match!&#34;
            )

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to open session, authenticate and acquire shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.auth_strict_key:
            self.logger.debug(f&#34;Attempting to validate {self.host} public key is in known hosts&#34;)
            self._verify_key()

        self.session_lock.acquire()
        await self._authenticate()

        if self.auth_strict_key:
            self.logger.debug(
                f&#34;Attempting to validate {self.host} public key is in known hosts and is valid&#34;
            )
            self._verify_key_value()

        self.session_lock.release()
        # it seems we must pass a terminal type to force a pty(?) which i think we want in like...
        # every case?? https://invisible-island.net/ncurses/ncurses.faq.html#xterm_color
        # set encoding to None so we get bytes for consistency w/ other scrapli transports
        self.stdin, self.stdout, self.stderr = await self.session.open_session(
            term_type=&#34;xterm&#34;, encoding=None
        )

    async def _authenticate(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to try all means of authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if authentication fails

        &#34;&#34;&#34;
        common_args = {
            &#34;host&#34;: self.host,
            &#34;port&#34;: self.port,
            &#34;username&#34;: self.auth_username,
            &#34;known_hosts&#34;: None,
            &#34;agent_path&#34;: None,
        }

        if self.auth_private_key:
            if await self._authenticate_private_key(common_args=common_args):
                self.logger.debug(f&#34;Authenticated to host {self.host} with public key auth&#34;)
                return
            if not self.auth_password or not self.auth_username:
                msg = (
                    f&#34;Failed to authenticate to host {self.host} with private key &#34;
                    f&#34;`{self.auth_private_key}`. Unable to continue authentication, &#34;
                    &#34;missing username, password, or both.&#34;
                )
                self.logger.critical(msg)
                raise ScrapliAuthenticationFailed(msg)

        if not await self._authenticate_password(common_args=common_args):
            msg = f&#34;Authentication to host {self.host} failed&#34;
            self.logger.critical(msg)
            self.session_lock.release()
            raise ScrapliAuthenticationFailed(msg)

        self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)

    async def _authenticate_private_key(self, common_args: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34;
        Attempt to authenticate with key based authentication

        Args:
            common_args: Dict of kwargs that are common between asyncssh auth/open methods

        Returns:
            bool: True if authentication succeeds, otherwise False

        Raises:
            ScrapliTimeout: if authentication times out
            Exception: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session = await asyncio.wait_for(
                connect(client_keys=self.auth_private_key, **common_args),
                timeout=self.timeout_socket,
            )
            return True
        except asyncio.TimeoutError:
            msg = (
                f&#34;Private key authentication with host {self.host} failed. &#34;
                &#34;Authentication Timed Out.&#34;
            )
            self.logger.exception(msg)
            raise ScrapliTimeout(msg)
        except PermissionDenied:
            self.logger.critical(
                f&#34;Private key authentication with host {self.host} failed. Authentication Error.&#34;
            )
            return False
        except Exception as exc:
            self.logger.critical(
                f&#34;Private key authentication with host {self.host} failed. Exception: {exc}.&#34;
            )
            raise exc

    async def _authenticate_password(self, common_args: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34;
        Attempt to authenticate with password/kbd-interactive authentication

        Args:
            common_args: Dict of kwargs that are common between asyncssh auth/open methods

        Returns:
            bool: True if authentication succeeds, otherwise False

        Raises:
            ScrapliTimeout: if authentication times out
            Exception: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session = await asyncio.wait_for(
                connect(password=self.auth_password, **common_args), timeout=self.timeout_socket
            )
            return True
        except asyncio.TimeoutError:
            msg = f&#34;Password authentication with host {self.host} failed. Authentication Timed Out.&#34;
            self.logger.exception(msg)
            raise ScrapliTimeout(msg)
        except PermissionDenied:
            self.logger.critical(
                f&#34;Password authentication with host {self.host} failed. Authentication Error.&#34;
            )
            return False
        except Exception as exc:
            self.logger.critical(
                f&#34;Password authentication with host {self.host} failed. Exception: {exc}.&#34;
            )
            raise exc

    def _isauthenticated(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        Args:
            N/A

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        isauthenticated: bool = self.session._auth_complete  # pylint:  disable=W0212
        return isauthenticated

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        self.session._auth_complete = False  # pylint:  disable=W0212
        self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if socket is alive and session authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        isauthenticated: bool = self.session._auth_complete  # pylint:  disable=W0212
        # this may need to be revisited in the future, but this seems to be a good check for
        # aliveness
        try:
            if (
                isauthenticated
                and self.session._transport.is_closing() is False  # pylint:  disable=W0212
            ):
                return True
        except AttributeError:
            pass
        return False

    @requires_open_session()
    async def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes output as read from channel

        Raises:
            ScrapliTimeout: if async read does not complete within timeout_transport interval

        &#34;&#34;&#34;
        try:
            output: bytes = await asyncio.wait_for(
                self.stdout.read(65535), timeout=self.timeout_transport
            )
            return output
        except asyncio.TimeoutError:
            msg = f&#34;Timed out reading from transport, transport timeout: {self.timeout_transport}&#34;
            self.logger.exception(msg)
            raise ScrapliTimeout(msg)

    @requires_open_session()
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.stdin.write(channel_input.encode())

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.timeout_transport = set_timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#39;out of band&#39; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: not yet implemented for asyncssh

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for asyncssh.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport"><code class="flex name class">
<span>class <span class="ident">AsyncSSHTransport</span></span>
<span>(</span><span>host: str, port: int = -1, auth_username: str = '', auth_private_key: str = '', auth_password: str = '', auth_strict_key: bool = True, timeout_socket: int = 5, timeout_transport: int = 5, timeout_exit: bool = True, keepalive: bool = False, keepalive_interval: int = 30, keepalive_type: str = '', keepalive_pattern: str = '\x05', ssh_config_file: str = '', ssh_known_hosts_file: str = '')</span>
</code></dt>
<dd>
<div class="desc"><p>Helper class that provides a standard way to create an ABC using
inheritance.</p>
<p>AsyncSSHTransport Object</p>
<p>Inherit from Transport ABC
AsyncSSHTransport &lt;- Transport (ABC)</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>host ip/name to connect to</dd>
<dt><strong><code>port</code></strong></dt>
<dd>port to connect to</dd>
<dt><strong><code>auth_username</code></strong></dt>
<dd>username for authentication</dd>
<dt><strong><code>auth_private_key</code></strong></dt>
<dd>path to private key for authentication</dd>
<dt><strong><code>auth_password</code></strong></dt>
<dd>password for authentication</dd>
<dt><strong><code>auth_strict_key</code></strong></dt>
<dd>True/False to enforce strict key checking (default is True)</dd>
<dt><strong><code>timeout_socket</code></strong></dt>
<dd>timeout for establishing socket in seconds</dd>
<dt><strong><code>timeout_transport</code></strong></dt>
<dd>timeout for ssh transport in seconds</dd>
<dt><strong><code>timeout_exit</code></strong></dt>
<dd>True/False close transport if timeout encountered. If False and keepalives
are in use, keepalives will prevent program from exiting so you should be sure to
catch Timeout exceptions and handle them appropriately</dd>
<dt><strong><code>keepalive</code></strong></dt>
<dd>whether or not to try to keep session alive</dd>
<dt><strong><code>keepalive_interval</code></strong></dt>
<dd>interval to use for session keepalives</dd>
<dt><strong><code>keepalive_type</code></strong></dt>
<dd>network|standard &ndash; 'network' sends actual characters over the
transport channel. This is useful for network-y type devices that may not support
'standard' keepalive mechanisms. 'standard' is not currently implemented w/ asyncssh</dd>
<dt><strong><code>keepalive_pattern</code></strong></dt>
<dd>pattern to send to keep network channel alive. Default is
u'' which is equivalent to 'ctrl+e'. This pattern moves cursor to end of the
line which should be an innocuous pattern. This will only be entered <em>if</em> a lock
can be acquired. This is only applicable if using keepalives and if the keepalive
type is 'network'</dd>
<dt><strong><code>ssh_config_file</code></strong></dt>
<dd>string to path for ssh config file</dd>
<dt><strong><code>ssh_known_hosts_file</code></strong></dt>
<dd>string to path for ssh known hosts file</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class AsyncSSHTransport(AsyncTransport):
    def __init__(
        self,
        host: str,
        port: int = -1,
        auth_username: str = &#34;&#34;,
        auth_private_key: str = &#34;&#34;,
        auth_password: str = &#34;&#34;,
        auth_strict_key: bool = True,
        timeout_socket: int = 5,
        timeout_transport: int = 5,
        timeout_exit: bool = True,
        keepalive: bool = False,
        keepalive_interval: int = 30,
        keepalive_type: str = &#34;&#34;,
        keepalive_pattern: str = &#34;\005&#34;,
        ssh_config_file: str = &#34;&#34;,
        ssh_known_hosts_file: str = &#34;&#34;,
    ) -&gt; None:
        &#34;&#34;&#34;
        AsyncSSHTransport Object

        Inherit from Transport ABC
        AsyncSSHTransport &lt;- Transport (ABC)

        Args:
            host: host ip/name to connect to
            port: port to connect to
            auth_username: username for authentication
            auth_private_key: path to private key for authentication
            auth_password: password for authentication
            auth_strict_key: True/False to enforce strict key checking (default is True)
            timeout_socket: timeout for establishing socket in seconds
            timeout_transport: timeout for ssh transport in seconds
            timeout_exit: True/False close transport if timeout encountered. If False and keepalives
                are in use, keepalives will prevent program from exiting so you should be sure to
                catch Timeout exceptions and handle them appropriately
            keepalive: whether or not to try to keep session alive
            keepalive_interval: interval to use for session keepalives
            keepalive_type: network|standard -- &#39;network&#39; sends actual characters over the
                transport channel. This is useful for network-y type devices that may not support
                &#39;standard&#39; keepalive mechanisms. &#39;standard&#39; is not currently implemented w/ asyncssh
            keepalive_pattern: pattern to send to keep network channel alive. Default is
                u&#39;\005&#39; which is equivalent to &#39;ctrl+e&#39;. This pattern moves cursor to end of the
                line which should be an innocuous pattern. This will only be entered *if* a lock
                can be acquired. This is only applicable if using keepalives and if the keepalive
                type is &#39;network&#39;
            ssh_config_file: string to path for ssh config file
            ssh_known_hosts_file: string to path for ssh known hosts file

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        cfg_port, cfg_user, cfg_private_key = self._process_ssh_config(host, ssh_config_file)

        if port == -1:
            port = cfg_port or 22

        super().__init__(
            host,
            port,
            timeout_socket,
            timeout_transport,
            timeout_exit,
            keepalive,
            keepalive_interval,
            keepalive_type,
            keepalive_pattern,
        )

        self.auth_username: str = auth_username or cfg_user
        self.auth_private_key: str = auth_private_key or cfg_private_key
        self.auth_password: str = auth_password
        self.auth_strict_key: bool = auth_strict_key
        self.ssh_known_hosts_file: str = ssh_known_hosts_file
        self.port = port
        self.session_lock: Lock = Lock()

        self.session: SSHClientConnection
        self.stdout: SSHReader
        self.stdin: SSHWriter
        self.stderr: SSHReader

    @staticmethod
    def _process_ssh_config(host: str, ssh_config_file: str) -&gt; Tuple[Optional[int], str, str]:
        &#34;&#34;&#34;
        Method to parse ssh config file

        In the future this may move to be a &#39;helper&#39; function as it should be very similar between
        asyncssh and and paramiko/ssh2-python... for now it can be a static method as there may be
        varying supported args between the transport drivers.

        Args:
            host: host to lookup in ssh config file
            ssh_config_file: string path to ssh config file; passed down from `Scrape`, or the
                `NetworkDriver` or subclasses of it, in most cases.

        Returns:
            Tuple: port to use for ssh, username to use for ssh, identity file (private key) to
                use for ssh auth

        Raises:
            N/A

        &#34;&#34;&#34;
        ssh = SSHConfig(ssh_config_file)
        host_config = ssh.lookup(host)
        return host_config.port, host_config.user or &#34;&#34;, host_config.identity_file or &#34;&#34;

    def _verify_key(self) -&gt; None:
        &#34;&#34;&#34;
        Verify target host public key, raise exception if invalid/unknown

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            KeyVerificationFailed: if host is not in known hosts

        &#34;&#34;&#34;
        known_hosts = SSHKnownHosts(self.ssh_known_hosts_file)

        if self.host not in known_hosts.hosts.keys():
            raise KeyVerificationFailed(f&#34;{self.host} not in known_hosts!&#34;)

    def _verify_key_value(self) -&gt; None:
        &#34;&#34;&#34;
        Verify target host public key, raise exception if invalid/unknown

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            KeyVerificationFailed: if host is in known hosts but public key does not match

        &#34;&#34;&#34;
        known_hosts = SSHKnownHosts(self.ssh_known_hosts_file)

        remote_server_key = self.session.get_server_host_key()
        remote_public_key = remote_server_key.export_public_key().split()[1].decode()

        if known_hosts.hosts[self.host][&#34;public_key&#34;] != remote_public_key:
            raise KeyVerificationFailed(
                f&#34;{self.host} in known_hosts but public key does not match!&#34;
            )

    async def open(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to open session, authenticate and acquire shell

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if self.auth_strict_key:
            self.logger.debug(f&#34;Attempting to validate {self.host} public key is in known hosts&#34;)
            self._verify_key()

        self.session_lock.acquire()
        await self._authenticate()

        if self.auth_strict_key:
            self.logger.debug(
                f&#34;Attempting to validate {self.host} public key is in known hosts and is valid&#34;
            )
            self._verify_key_value()

        self.session_lock.release()
        # it seems we must pass a terminal type to force a pty(?) which i think we want in like...
        # every case?? https://invisible-island.net/ncurses/ncurses.faq.html#xterm_color
        # set encoding to None so we get bytes for consistency w/ other scrapli transports
        self.stdin, self.stdout, self.stderr = await self.session.open_session(
            term_type=&#34;xterm&#34;, encoding=None
        )

    async def _authenticate(self) -&gt; None:
        &#34;&#34;&#34;
        Parent method to try all means of authentication

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            ScrapliAuthenticationFailed: if authentication fails

        &#34;&#34;&#34;
        common_args = {
            &#34;host&#34;: self.host,
            &#34;port&#34;: self.port,
            &#34;username&#34;: self.auth_username,
            &#34;known_hosts&#34;: None,
            &#34;agent_path&#34;: None,
        }

        if self.auth_private_key:
            if await self._authenticate_private_key(common_args=common_args):
                self.logger.debug(f&#34;Authenticated to host {self.host} with public key auth&#34;)
                return
            if not self.auth_password or not self.auth_username:
                msg = (
                    f&#34;Failed to authenticate to host {self.host} with private key &#34;
                    f&#34;`{self.auth_private_key}`. Unable to continue authentication, &#34;
                    &#34;missing username, password, or both.&#34;
                )
                self.logger.critical(msg)
                raise ScrapliAuthenticationFailed(msg)

        if not await self._authenticate_password(common_args=common_args):
            msg = f&#34;Authentication to host {self.host} failed&#34;
            self.logger.critical(msg)
            self.session_lock.release()
            raise ScrapliAuthenticationFailed(msg)

        self.logger.debug(f&#34;Authenticated to host {self.host} with password&#34;)

    async def _authenticate_private_key(self, common_args: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34;
        Attempt to authenticate with key based authentication

        Args:
            common_args: Dict of kwargs that are common between asyncssh auth/open methods

        Returns:
            bool: True if authentication succeeds, otherwise False

        Raises:
            ScrapliTimeout: if authentication times out
            Exception: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session = await asyncio.wait_for(
                connect(client_keys=self.auth_private_key, **common_args),
                timeout=self.timeout_socket,
            )
            return True
        except asyncio.TimeoutError:
            msg = (
                f&#34;Private key authentication with host {self.host} failed. &#34;
                &#34;Authentication Timed Out.&#34;
            )
            self.logger.exception(msg)
            raise ScrapliTimeout(msg)
        except PermissionDenied:
            self.logger.critical(
                f&#34;Private key authentication with host {self.host} failed. Authentication Error.&#34;
            )
            return False
        except Exception as exc:
            self.logger.critical(
                f&#34;Private key authentication with host {self.host} failed. Exception: {exc}.&#34;
            )
            raise exc

    async def _authenticate_password(self, common_args: Dict[str, Any]) -&gt; bool:
        &#34;&#34;&#34;
        Attempt to authenticate with password/kbd-interactive authentication

        Args:
            common_args: Dict of kwargs that are common between asyncssh auth/open methods

        Returns:
            bool: True if authentication succeeds, otherwise False

        Raises:
            ScrapliTimeout: if authentication times out
            Exception: if unknown (i.e. not auth failed) exception occurs

        &#34;&#34;&#34;
        try:
            self.session = await asyncio.wait_for(
                connect(password=self.auth_password, **common_args), timeout=self.timeout_socket
            )
            return True
        except asyncio.TimeoutError:
            msg = f&#34;Password authentication with host {self.host} failed. Authentication Timed Out.&#34;
            self.logger.exception(msg)
            raise ScrapliTimeout(msg)
        except PermissionDenied:
            self.logger.critical(
                f&#34;Password authentication with host {self.host} failed. Authentication Error.&#34;
            )
            return False
        except Exception as exc:
            self.logger.critical(
                f&#34;Password authentication with host {self.host} failed. Exception: {exc}.&#34;
            )
            raise exc

    def _isauthenticated(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if session is authenticated

        Args:
            N/A

        Returns:
            bool: True if authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        isauthenticated: bool = self.session._auth_complete  # pylint:  disable=W0212
        return isauthenticated

    def close(self) -&gt; None:
        &#34;&#34;&#34;
        Close session and socket

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.session_lock.acquire()
        self.session.close()
        self.session._auth_complete = False  # pylint:  disable=W0212
        self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)
        self.session_lock.release()

    def isalive(self) -&gt; bool:
        &#34;&#34;&#34;
        Check if socket is alive and session is authenticated

        Args:
            N/A

        Returns:
            bool: True if socket is alive and session authenticated, else False

        Raises:
            N/A

        &#34;&#34;&#34;
        isauthenticated: bool = self.session._auth_complete  # pylint:  disable=W0212
        # this may need to be revisited in the future, but this seems to be a good check for
        # aliveness
        try:
            if (
                isauthenticated
                and self.session._transport.is_closing() is False  # pylint:  disable=W0212
            ):
                return True
        except AttributeError:
            pass
        return False

    @requires_open_session()
    async def read(self) -&gt; bytes:
        &#34;&#34;&#34;
        Read data from the channel

        Args:
            N/A

        Returns:
            bytes: bytes output as read from channel

        Raises:
            ScrapliTimeout: if async read does not complete within timeout_transport interval

        &#34;&#34;&#34;
        try:
            output: bytes = await asyncio.wait_for(
                self.stdout.read(65535), timeout=self.timeout_transport
            )
            return output
        except asyncio.TimeoutError:
            msg = f&#34;Timed out reading from transport, transport timeout: {self.timeout_transport}&#34;
            self.logger.exception(msg)
            raise ScrapliTimeout(msg)

    @requires_open_session()
    def write(self, channel_input: str) -&gt; None:
        &#34;&#34;&#34;
        Write data to the channel

        Args:
            channel_input: string to send to channel

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        self.stdin.write(channel_input.encode())

    def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
        &#34;&#34;&#34;
        Set session timeout

        Args:
            timeout: timeout in seconds

        Returns:
            N/A  # noqa: DAR202

        Raises:
            N/A

        &#34;&#34;&#34;
        if isinstance(timeout, int):
            set_timeout = timeout
        else:
            set_timeout = self.timeout_transport
        self.timeout_transport = set_timeout

    def _keepalive_standard(self) -&gt; None:
        &#34;&#34;&#34;
        Send &#39;out of band&#39; (protocol level) keepalives to devices.

        Args:
            N/A

        Returns:
            N/A  # noqa: DAR202

        Raises:
            NotImplementedError: not yet implemented for asyncssh

        &#34;&#34;&#34;
        raise NotImplementedError(&#34;No &#39;standard&#39; keepalive mechanism for asyncssh.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>scrapli.transport.async_transport.AsyncTransport</li>
<li>scrapli.transport.base_transport.TransportBase</li>
<li>abc.ABC</li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Close session and socket</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;
    Close session and socket

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    self.session_lock.acquire()
    self.session.close()
    self.session._auth_complete = False  # pylint:  disable=W0212
    self.logger.debug(f&#34;Channel to host {self.host} closed&#34;)
    self.session_lock.release()</code></pre>
</details>
</dd>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.isalive"><code class="name flex">
<span>def <span class="ident">isalive</span></span>(<span>self) -> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if socket is alive and session is authenticated</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>bool</code></dt>
<dd>True if socket is alive and session authenticated, else False</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def isalive(self) -&gt; bool:
    &#34;&#34;&#34;
    Check if socket is alive and session is authenticated

    Args:
        N/A

    Returns:
        bool: True if socket is alive and session authenticated, else False

    Raises:
        N/A

    &#34;&#34;&#34;
    isauthenticated: bool = self.session._auth_complete  # pylint:  disable=W0212
    # this may need to be revisited in the future, but this seems to be a good check for
    # aliveness
    try:
        if (
            isauthenticated
            and self.session._transport.is_closing() is False  # pylint:  disable=W0212
        ):
            return True
    except AttributeError:
        pass
    return False</code></pre>
</details>
</dd>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.open"><code class="name flex">
<span>async def <span class="ident">open</span></span>(<span>self) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Parent method to open session, authenticate and acquire shell</p>
<h2 id="args">Args</h2>
<p>N/A</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def open(self) -&gt; None:
    &#34;&#34;&#34;
    Parent method to open session, authenticate and acquire shell

    Args:
        N/A

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    if self.auth_strict_key:
        self.logger.debug(f&#34;Attempting to validate {self.host} public key is in known hosts&#34;)
        self._verify_key()

    self.session_lock.acquire()
    await self._authenticate()

    if self.auth_strict_key:
        self.logger.debug(
            f&#34;Attempting to validate {self.host} public key is in known hosts and is valid&#34;
        )
        self._verify_key_value()

    self.session_lock.release()
    # it seems we must pass a terminal type to force a pty(?) which i think we want in like...
    # every case?? https://invisible-island.net/ncurses/ncurses.faq.html#xterm_color
    # set encoding to None so we get bytes for consistency w/ other scrapli transports
    self.stdin, self.stdout, self.stderr = await self.session.open_session(
        term_type=&#34;xterm&#34;, encoding=None
    )</code></pre>
</details>
</dd>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.read"><code class="name flex">
<span>def <span class="ident">read</span></span>(<span>*args: Union[str, int], **kwargs: Dict[str, Union[str, int]]) -> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires_open_session_wrapper(
    *args: Union[str, int], **kwargs: Dict[str, Union[str, int]],
) -&gt; Any:
    try:
        return wrapped_func(*args, **kwargs)
    except AttributeError:
        raise ConnectionNotOpened(
            &#34;Attempting to call method that requires an open connection, but connection is &#34;
            &#34;not open. Call the `.open()` method of your connection object, or use a &#34;
            &#34;context manager to ensue your connection has been opened.&#34;
        )</code></pre>
</details>
</dd>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.set_timeout"><code class="name flex">
<span>def <span class="ident">set_timeout</span></span>(<span>self, timeout: Union[int, NoneType] = None) -> NoneType</span>
</code></dt>
<dd>
<div class="desc"><p>Set session timeout</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>N/A
# noqa: DAR202</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="raises">Raises</h2>
<dl>
<dt><code>N/A</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_timeout(self, timeout: Optional[int] = None) -&gt; None:
    &#34;&#34;&#34;
    Set session timeout

    Args:
        timeout: timeout in seconds

    Returns:
        N/A  # noqa: DAR202

    Raises:
        N/A

    &#34;&#34;&#34;
    if isinstance(timeout, int):
        set_timeout = timeout
    else:
        set_timeout = self.timeout_transport
    self.timeout_transport = set_timeout</code></pre>
</details>
</dd>
<dt id="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.write"><code class="name flex">
<span>def <span class="ident">write</span></span>(<span>*args: Union[str, int], **kwargs: Dict[str, Union[str, int]]) -> Any</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def requires_open_session_wrapper(
    *args: Union[str, int], **kwargs: Dict[str, Union[str, int]],
) -&gt; Any:
    try:
        return wrapped_func(*args, **kwargs)
    except AttributeError:
        raise ConnectionNotOpened(
            &#34;Attempting to call method that requires an open connection, but connection is &#34;
            &#34;not open. Call the `.open()` method of your connection object, or use a &#34;
            &#34;context manager to ensue your connection has been opened.&#34;
        )</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="scrapli_asyncssh.transport" href="index.html">scrapli_asyncssh.transport</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport">AsyncSSHTransport</a></code></h4>
<ul class="two-column">
<li><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.close" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.close">close</a></code></li>
<li><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.isalive" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.isalive">isalive</a></code></li>
<li><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.open" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.open">open</a></code></li>
<li><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.read" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.read">read</a></code></li>
<li><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.set_timeout" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.set_timeout">set_timeout</a></code></li>
<li><code><a title="scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.write" href="#scrapli_asyncssh.transport.asyncssh_.AsyncSSHTransport.write">write</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>